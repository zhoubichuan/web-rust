---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 1.简单项目

## 摄氏度华氏度转换

```rust
use std::{cmp::Ordering, io};
fn main() {
    println!("摄氏度转华氏度，华氏度转摄氏度"); // ! 表示宏
    println!("请输入 1或2 数字，然后按回车键");
    let mut guess = String::new(); // :: 类型下的静态方法
    io::stdin().read_line(&mut guess).expect("输入错误"); // expect 错误处理
    let guess: u32 = guess.trim().parse().expect("输入数据有误"); // . 调用方法
    println!("请输入度数数字，然后按回车键");
    let mut num = String::new(); // :: 类型下的静态方法
    io::stdin().read_line(&mut num).expect("输入错误"); // expect 错误处理
    let num: f32 = num.trim().parse().expect("输入数据有误"); // . 调用方法
    let res = if guess == 1 {
        (num - 32.0) / 1.8
    } else {
        num * 1.8 + 32.0
    };
    println!("你的数据是: {res}")
}
```

## 猜数字游戏

```rust
use std::{cmp::Ordering, io}; // use 使用模块  :: 模块下的 方法

use rand::Rng;
fn main() {
    println!("100以内猜数字游戏"); // ! 表示宏
    let num_f = rand::thread_rng().gen_range(1..=100);
    loop {
        println!("请输入 1-100 数字，然后按回车键");
        let mut guess = String::new(); // :: 类型下的静态方法
        io::stdin().read_line(&mut guess).expect("输入错误");// expect 错误处理
        let guess: u32 = guess.trim().parse().expect("输入数据有误"); // . 调用方法
        match guess.cmp(&num_f) {
            Ordering::Less => println!("你猜小了"),
            Ordering::Equal => {
                println!("你猜对了");
                break;
            }
            Ordering::Greater => println!("你猜大了"),
        }
        println!("你猜的数据是: {guess}")
    }
}
```
## 数组累加

```rust
use std::{cmp::Ordering, io};
fn main() {
    println!("输入整数，用空格分隔");
    let mut guess = String::new(); // :: 类型下的静态方法
    io::stdin().read_line(&mut guess).expect("输入错误"); // expect 错误处理
    let mut arr: [u32; 5] = [0, 0, 0, 0, 0];
    let v: Vec<&str> = guess.split(' ').collect();
    let mut index = 0;
    for num in v {
        arr[index] = num.trim().parse().expect("输入数据有误");
        index += 1;
        if index == 5 {
            break;
        }
    }
    let mut res: u32 = 0;
    for r in arr {
        res += r;
    }
    println!("你的输入是: {:?},你的结果是: {}",arr,res)
}
```
## 斐波那契数列

- loop

```rust
use std::{cmp::Ordering, io};
fn main() {
    println!("输入整数");
    let mut guess = String::new(); // :: 类型下的静态方法
    io::stdin().read_line(&mut guess).expect("输入错误"); // expect 错误处理
    let num: u32 = guess.trim().parse().expect("输入数据有误");
    let mut i: u32 = 0;
    let mut res: u32 = 1;
    let mut pre: u32 = 1;
    let mut total: u32 = 1;
    loop {
        total = res + pre;
        pre = res;
        res = total;
        i += 1;
        if i == 0 || i == 1 {
            total = 1;
            break; // 用于跳出循环
        }
        if(i != num){
            break;
        }
    }
    println!("你的结果是: {}", res)
}
```

- while

```rust
use std::{cmp::Ordering, io};
fn main() {
    println!("输入整数");
    let mut guess = String::new(); // :: 类型下的静态方法
    io::stdin().read_line(&mut guess).expect("输入错误"); // expect 错误处理
    let num: u32 = guess.trim().parse().expect("输入数据有误");
    let mut i: u32 = 0;
    let mut res: u32 = 1;
    let mut pre: u32 = 1;
    let mut total: u32 = 1;
    while i != num {
        total = res + pre;
        pre = res;
        res = total;
        i += 1;
    }
    if i == 0||i == 1 {
        total = 1;
    }
    println!("你的结果是: {}", total)
}
```
## 质数判断

```rust
use std::io;
fn main() {
    println!("输入整数");
    let mut guess = String::new(); // :: 类型下的静态方法
    io::stdin().read_line(&mut guess).expect("输入错误"); // expect 错误处理
    let num: u32 = guess.trim().parse().expect("输入数据有误");
    let mut res: u32 = 0;
    for item in 2..num {
        res = num % item;
        if res == 0 {
            println!("{num}不是质数");
            break;
        }
    }
    if num == 0 || num == 1 {
        return println!("{num}不是质数");
    }
    if res != 0 {
        println!("{num}是质数");
    }
}
```
## 冒泡排序

```rust
use rand::Rng;
fn main(){
    println!("随机10个数");
    let mut numbers = [0u32;10];
    for i in 0..10 {
        numbers[i] = rand::thread_rng().gen_range(1..10);
    }
    println!("ERRORE:{:?}",numbers);

    let len = numbers.len();

    for i in 0..len {
        for j in 0..len -i -1{
            if numbers[j]>numbers[j+1]{
                numbers.swap(j, j+1)
            }
        }
    }
    println!("AFTER:{:?}",numbers)
}
```
## 字符次数

- a-z 26 个字符，其余字符舍弃
- 如果输入的文本中有大写的 A-Z，计数到对应的小写字母上，也就是说大小写不敏感
- 最终输入出的时候一行一个结果，总共输出 26 行，例如 a => 1 这样的格式

```rust
use std::{collections::HashMap, fmt::format, io}; // use 使用模块  :: 模块下的 方法
fn main() {
    println!("请输入字符，然后按回车键，计算字符次数");
    let str = String::from("abcdefghigklmnopqrstuvwxyz");
    let mut obj = HashMap::new();
    let mut s = String::new(); // :: 类型下的静态方法
    io::stdin().read_line(&mut s).expect("输入错误"); // expect 错误处理
    s = s.trim().to_lowercase();
    for c in s.chars() {
        if str.contains(c) {
            if obj.contains_key(&c) {
                let count = obj.get(&c).unwrap() + 1;
                obj.insert(c, count);
            } else {
                obj.insert(c, 1);
            }
        }
    }
    for w in str.chars() {
        if obj.contains_key(&w){
            let target = format(format_args!("{} => {}", w, obj.get(&w).unwrap()));
            println!("{target}")
        }else {
            let target = format(format_args!("{} => {}", w, 0));
            println!("{target}")
        }
    }
}
```
## 最大公约数

- 用户输入 2 个 2^31 - 1 以内的正整数，计算其最大公约数（推荐使用辗转相除法）

```rust
use std::io;
fn main() {
    println!("输入 2 个 2^31 - 1 以内的正整数用空格隔开然后回车，计算其最大公约数");
    let mut s = String::new(); // :: 类型下的静态方法
    io::stdin().read_line(&mut s).expect("输入错误"); // expect 错误处理
    let arr: Vec<&str> = s.trim().split(" ").collect();
    let num_a = arr[0].trim().parse().expect("数据有误");
    let num_b = arr[1].trim().parse().expect("数据有误");
    let mut max: i32;
    let mut min: i32;
    if num_a > num_b {
        max = num_a;
        min = num_b;
    } else {
        max = num_b;
        min = num_a;
    }
    while max % min != 0 {
        let res = max % min;
        max = min;
        min = res;
    }
    println!("最大公约数:{}", min)
}
```