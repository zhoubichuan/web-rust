---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 三.语句

::: tip 前言
语句是指要执行的一些操作和产生副作用的表达式：由`关键字`和`标识符`及`操作符`组成的表达式组成，通过不同的`关键字`可以分为几类
:::

## 1.声明语句

用于声明各种语言项，包括声明变量，静态变量，常量，结构体，函数等，以及通过 extern 和 use 关键字引入包和模块等

### 1.1 const

- 关键字`const`用于声明`常量`

```rust
const a: i32 = 123
```

### 1.1 let

变量有两部分组成：值 、 类型

值可以分为：不可变变量、可变变量

类型可以分为不同的[数据类型](/1.base/1.js/4.variableobj)

- 关键字`let`用于声明`不可变变量`

```rust
let a = 123;
```

- 关键字`mut`用于声明`可变变量`

```rust
let mut a = 123;
a = 456;
```

### 1.2 function

```js
function fn() {}
```

[函数](/1.base/1.js/6.closure)

### 1.3 require

```js
var a = require("./a.js")
```

[模块化](/1.base/1.js/8.async)

## 2.表达式语句

表达式主要用于计算求值

Rust 编译器在解析代码时：

- 如果遇到分号，就会继续往后面执行
- 如果遇到语句，就会执行语句
- 如果遇到表达式，就会对表达式求值
- 如果分号后面什么都没有，就会补上单元值()
- 当遇到函数时，就会将函数体的花括号识别为块表达式

### 2.1 块表达式

块表达式是由一对花括号和一系列表达式组成的，它总是返回块中最后一个表达式的值

```sh
var a = 1;
a = a + 10;
```

### 2.2 位置表达式

位置表达式(Place Expression)一般叫做左值，是表示内存位置的表达式，有以下几类：

- 本地变量
- 静态变量
- 解引用 (\* express)
- 数组索引 (expr[expr])
- 字段引用 (expr.field)
- 位置表达式组合

通过位置表达式可以对某个数据单元的内存进行读写。位置表达式可以用于赋值

### 2.3 值表达式

值表达式(Value Expression)一般叫做右值，值表达式引用了某个存储单元地址中的数据。它相当于数据，只能进行读操作。

从语义角度来说，位置表达式代表了持久性数据，值表达式代表了临时数据。位置表达式一般有持久的状态，值表达式要不是字面量，要不就是表达式求值过程中创建的临时值

- 流程控制表达式


流程控制

## 1.if

- 表达式一定会有值，所以 if 条件表达式的分支必须返回同一个类型的值

```rust
let n = 13;
// if 表达式可以用来赋值
let big_n = if n < 10 && n > -10 {
    // 分支必须返回同一个类型的值
    10 * n
} else {
    // 自动截取
    n / 2
};
assert_eq!(big_n, 6);
```

## 2.`for ... in`

```rust
for n in 1..101 {
    if n % 15 == 0 {
        println!("fizzbuzz");
    } else if n % 3 == 0 {
        println!("fizz");
    } else if n % 5 == 0 {
        println!("buzz");
    } else {
        println!("{}", n);
    }
}
```

## 3.loop

- 循环

```rust
let mut n = 1;
loop {
    if n > 101 { break; }
    if n % 15 == 0 {
        println!("fizzbuzz");
    } else if n % 3 == 0 {
        println!("fizz");
    } else if n % 5 == 0 {
        println!("buzz");
    } else {
        println!("{}", n);
    }
    n += 1;
}
```

## 4.while

```rust
let mut n = 1;
while n < 101 {
    if n % 15 == 0 {
        println!("fizzbuzz");
    } else if n % 3 == 0 {
        println!("fizz");
    } else if n % 5 == 0 {
        println!("buzz");
    } else {
        println!("{}", n);
    }
    n += 1;
}
```

## 5.match

- 匹配各种情况

```rust
let number = 42;
match number {
    // 模式为单个值
    0 => println!("Origin"),
    // 模式为Range
    1...3 => println!("All"),
    // 模式为 多个值
    | 5 | 7 | 13  => println!("Bad Luck"),
    // 绑定模式，将模式中的值绑定给一个变量，供右边执行代码使用
    n @ 42 => println!("Answer is {}", n),
    // _ 通配符处理剩余情况
    _ => println!("Common"),
}
```

## 6.`if let`

```rust
let boolean = true;
let mut binary = 0;
// if let 左侧为模式，右侧为匹配的值
if let true = boolean {
    binary = 1;
}
assert_eq!(binary, 1);
```

## 7.`while let`

```rust
let mut v = vec![1,2,3,4,5];
while let Some(x) = v.pop() {
    println!("{}", x);
}
```
